//∙AML
// Copyright (C) 2018-2021 Dmitry Maslov
// For conditions of distribution and use, see readme.txt

#pragma once

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//   Макросы Assert/Verify/Halt
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Макрос Assert проверяет переданное ему логическое выражение EXPRESSION, и если оно равно true, то ничего не делает.
// Но если выражение равно false, то показывает пользователю модальное окно с подробным сообщением об ошибке (для GUI
// приложения), или выбрасывает исключение EAssertion (для консольного приложения). Также это сообщение дублируется
// в системный журнал. Это поведение может быть изменено см. функцию DebugHelper::SetAssertHandler. В production
// сборках макрос Assert всегда полностью отключен, а выражение EXPRESSION не вычисляется

// Макрос Verify аналогичен макросу Assert и ведёт себя точно так же. Его главное отличие от Assert в том, что он всегда
// возвращает значение bool, соответствующее значению выражения EXPRESSION. И поэтому обычно используется в конструкциях
// вида "if (Verify(expression && "Error message")) { ... }". В production сборках макрос Verify не выводит никаких
// сообщений и не генерирует исключений, однако в отличие от Assert вычисляет значение выражения EXPRESSION

// Макрос Halt(MESSAGE) работает аналогично Assert(false && MESSAGE), то есть он всегда выводит сообщение об ошибке
// (для GUI проложения) или генерирует исключение EHalt (для консольного приложения). Его важное отличие от Assert
// состоит в том, что передаваемое значение MESSAGE должно быть строкой (любого типа) с сообщением об ошибке. В
// production сборках макрос Halt всегда полностью отключен, а выражение MESSAGE не вычисляется

#define Assert(EXPRESSION) ((void) 0)
#define Verify(EXPRESSION) static_cast<bool>(EXPRESSION)
#define Halt(MESSAGE) ((void) 0)
